"""
Module for providing a service for managing manufacturers using the `ManufacturerRepo` repository.
"""
import logging
import re

from typing import List, Optional
from fastapi import Depends
from inventory_management_system_api.core.exceptions import MissingRecordError
from inventory_management_system_api.models.manufacturer import ManufacturerIn, ManufacturerOut
from inventory_management_system_api.repositories.manufacturer import ManufacturerRepo
from inventory_management_system_api.schemas.manufacturer import (
    ManufacturerPatchRequstSchema,
    ManufacturerPostRequestSchema,
)

logger = logging.getLogger()


class ManufacturerService:
    """Service for managing manufacturers"""

    def __init__(
        self,
        manufacturer_repository: ManufacturerRepo = Depends(ManufacturerRepo),
    ) -> None:
        """
        Initialise the manufacturer service with a ManufacturerRepo

        :param manufacturer_repository: The `ManufacturerRepo` repository to use.
        """

        self._manufacturer_repository = manufacturer_repository

    def create(self, manufacturer: ManufacturerPostRequestSchema) -> ManufacturerOut:
        """
        Create a new manufacturer.
        :param manufacturer: The manufacturer to be created.
        :return: The created manufacturer.
        """
        code = self._generate_code(manufacturer.name)
        return self._manufacturer_repository.create(
            ManufacturerIn(
                name=manufacturer.name,
                code=code,
                url=manufacturer.url,
                address=manufacturer.address,
                telephone=manufacturer.telephone,
            )
        )

    def _generate_code(self, name: str) -> str:
        """
        Generate code for manufacturer based on its name, used to check for duplicate manufacturers

        The code is generated by changing name to lowercase and replacing spaces hypens,
        and removing trailing/preceding spaces

        :param name: The name of the manufacturer
        :return: The generated code for the manufacturer
        """
        name = name.lower().strip()
        return re.sub(r"\s", "-", name)

    def get(self, manufacturer_id: str) -> Optional[ManufacturerOut]:
        """
        Get manufacturer by its ID.

        :param: manufacturer_id: The ID of the requested manufacturer
        :return: The retrieved manufacturer, or None if not found
        """
        return self._manufacturer_repository.get(manufacturer_id)

    def list(self) -> List[ManufacturerOut]:
        """Get all manufactuers

        :return: list of all manufacturers
        """
        return self._manufacturer_repository.list()

    def update(self, manufacturer_id: str, manufacturer: ManufacturerPatchRequstSchema) -> ManufacturerOut:
        """Update a category by its ID


        :params: manufacturer_id: The ID of the manufacturer to be updated
        :return: The updates manufacturer
        :raises MissingRecordError: If manufacturer does not exist in database
        """
        update_data = manufacturer.dict(exclude_unset=True)

        logger.info(update_data)

        stored_manufacturer = self.get(manufacturer_id)
        if not stored_manufacturer:
            raise MissingRecordError(f"No manufacturer found with ID {manufacturer_id}")

        if "name" in update_data and update_data["name"] != stored_manufacturer.name:
            stored_manufacturer.name = update_data["name"]
            stored_manufacturer.code = self._generate_code(stored_manufacturer.name)

        # auto populates address object with current fields for those that have not been changed. This ensures that when
        # update_data is copied the address object has all the fields in the object so it can be inserted correctly
        if "address" in update_data:
            if "building_number" not in update_data["address"]:
                update_data["address"]["building_number"] = stored_manufacturer.address.building_number
            if "street_name" not in update_data["address"]:
                update_data["address"]["street_name"] = stored_manufacturer.address.street_name
            if "town" not in update_data["address"]:
                update_data["address"]["town"] = stored_manufacturer.address.town
            if "county" not in update_data["address"]:
                update_data["address"]["county"] = stored_manufacturer.address.county
            if "country" not in update_data["address"]:
                update_data["address"]["country"] = stored_manufacturer.address.country
            if "postcode" not in update_data["address"]:
                update_data["address"]["postcode"] = stored_manufacturer.address.postcode

        stored_manufacturer = stored_manufacturer.copy(update=update_data)
        return self._manufacturer_repository.update(manufacturer_id, ManufacturerIn(**stored_manufacturer.dict()))

    def delete(self, manufacturer_id: str) -> None:
        """
        Delete a manufacturer by its ID

        :param manufacturer_id: The ID of the manufacturer to delete

        """
        return self._manufacturer_repository.delete(manufacturer_id)
